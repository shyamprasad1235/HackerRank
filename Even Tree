#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <math.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* readline();
char* ltrim(char*);
char* rtrim(char*);
char** split_string(char*);

#define MAXN 105   // enough for constraints

// adjacency list
int *adj[MAXN];
int adjSize[MAXN];
int removableEdges;

// DFS function to calculate subtree sizes
int dfs(int node, int parent) {
    int subtreeSize = 1;  // count current node

    for (int i = 0; i < adjSize[node]; i++) {
        int child = adj[node][i];
        if (child != parent) {
            int childSize = dfs(child, node);
            if (childSize % 2 == 0) {
                removableEdges++;   // we can cut this edge
            } else {
                subtreeSize += childSize;
            }
        }
    }
    return subtreeSize;
}

int evenForest(int t_nodes, int t_edges, int t_from_count, int* t_from, int t_to_count, int* t_to) {
    // initialize adjacency
    for (int i = 1; i <= t_nodes; i++) {
        adj[i] = malloc(t_nodes * sizeof(int)); // safe upper bound
        adjSize[i] = 0;
    }

    // build undirected graph
    for (int i = 0; i < t_edges; i++) {
        int u = t_from[i];
        int v = t_to[i];
        adj[u][adjSize[u]++] = v;
        adj[v][adjSize[v]++] = u;
    }

    removableEdges = 0;
    dfs(1, -1); // root is node 1

    // free adjacency memory
    for (int i = 1; i <= t_nodes; i++) {
        free(adj[i]);
    }

    return removableEdges;
}

int main() {
    FILE* fptr = fopen(getenv("OUTPUT_PATH"), "w");

    char** t_nodes_edges = split_string(rtrim(readline()));

    char* t_nodes_endptr;
    char* t_nodes_str = t_nodes_edges[0];
    int t_nodes = strtol(t_nodes_str, &t_nodes_endptr, 10);

    char* t_edges_endptr;
    char* t_edges_str = t_nodes_edges[1];
    int t_edges = strtol(t_edges_str, &t_edges_endptr, 10);

    int t_from[t_edges];
    int t_to[t_edges];

    for (int t_i = 0; t_i < t_edges; t_i++) {
        char** t_from_to = split_string(rtrim(readline()));
        t_from[t_i] = strtol(t_from_to[0], NULL, 10);
        t_to[t_i] = strtol(t_from_to[1], NULL, 10);
    }

    // FIX: use t_edges for both counts
    int res = evenForest(t_nodes, t_edges, t_edges, t_from, t_edges, t_to);

    fprintf(fptr, "%d\n", res);

    fclose(fptr);

    return 0;
}

/* --- Helper functions from HackerRank template --- */
char* readline() {
    size_t alloc_length = 1024;
    size_t data_length = 0;
    char* data = malloc(alloc_length);

    while (true) {
        char* cursor = data + data_length;
        char* line = fgets(cursor, alloc_length - data_length, stdin);

        if (!line) break;
        data_length += strlen(cursor);

        if (data_length < alloc_length - 1 || data[data_length - 1] == '\n') break;

        alloc_length <<= 1;
        data = realloc(data, alloc_length);
    }

    if (data[data_length - 1] == '\n') {
        data[data_length - 1] = '\0';
    }

    return data;
}

char* ltrim(char* str) {
    while (*str != '\0' && isspace(*str)) str++;
    return str;
}

char* rtrim(char* str) {
    char* end = str + strlen(str) - 1;
    while (end >= str && isspace(*end)) end--;
    *(end + 1) = '\0';
    return str;
}

char** split_string(char* str) {
    char** splits = NULL;
    char* token = strtok(str, " ");
    int spaces = 0;

    while (token) {
        splits = realloc(splits, sizeof(char*) * ++spaces);
        splits[spaces - 1] = token;
        token = strtok(NULL, " ");
    }
    return splits;
}
